#include "assets/Vertex.hpp"
#include "assets/Mesh.hpp"

std::shared_ptr<Mesh> generate_cube() {
    std::vector<Vertex> V{
        {{1, 1, 0}}, // [00]
        {{0, 1, 0}}, // [01]
        {{1, 1, 1}}, // [02]
        {{0, 1, 1}}, // [03]
        {{1, 0, 0}}, // [04]
        {{0, 0, 0}}, // [05]
        {{0, 0, 1}}, // [06]
        {{1, 0, 1}}, // [07]
    };

    std::vector<GLuint> I{ 0, 1, 4, 5, 6, 1, 3, 0, 2, 4, 7, 6, 2, 3 };
    return std::make_shared<Mesh>(V, I, GL_TRIANGLE_STRIP);
}

std::shared_ptr<Mesh> generate_sphere(unsigned int sectors, unsigned int rings) {
    std::vector<Vertex> V{};
    std::vector<GLuint> I{};

    // Ensure the number of sectors wraps around nicely
    unsigned int totalSectors = sectors + 1;

    // Generate vertices
    for (unsigned int r = 0; r <= rings; ++r) {
        float const R = (float)r / (float)rings;
        // Phi goes from -pi/2 (south pole) to pi/2 (north pole)
        float const phi = -glm::pi<float>() / 2.0f + glm::pi<float>() * R;
        float const y = std::sin(phi);
        float const xz_radius = std::cos(phi);

        for (unsigned int s = 0; s <= sectors; ++s) {
            float const S = (float)s / (float)sectors;
            // Theta goes from 0 to 2*pi
            float const theta = 2.0f * glm::pi<float>() * S;
            float const x = std::cos(theta) * xz_radius;
            float const z = std::sin(theta) * xz_radius;

            V.push_back({ glm::vec3(x, y, z) });
        }
    }

    // Generate indices for a single long triangle strip using degenerate triangles
    for (unsigned int r = 0; r < rings; ++r) {
        // Stitch the current ring to the next one using degenerate triangles
        if (r > 0) {
            // Duplicate the last vertex of the previous strip to start a degenerate triangle
            I.push_back(r * totalSectors + sectors);
            // Duplicate the first vertex of the new strip to form a second degenerate triangle
            I.push_back(r * totalSectors);
        }

        // Generate indices for one horizontal strip (alternating winding isn't needed here if vertices are ordered correctly)
        for (unsigned int s = 0; s <= sectors; ++s) {
            // Top vertex of the quad
            I.push_back(r * totalSectors + s);
            // Bottom vertex of the quad
            I.push_back((r + 1) * totalSectors + s);
        }
    }

    return std::make_shared<Mesh>(V, I, GL_TRIANGLE_STRIP);
}